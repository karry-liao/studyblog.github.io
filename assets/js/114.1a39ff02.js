(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{889:function(t,a,s){"use strict";s.r(a);var e=s(16),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一、vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、vuex"}},[t._v("#")]),t._v(" 一、Vuex")]),t._v(" "),a("p",[a("strong",[t._v("State、 Getter、Mutation 、Action、 Module。")])]),t._v(" "),a("h3",{attrs:{id:"state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" State")]),t._v(" "),a("p",[t._v("Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。")]),t._v(" "),a("p",[t._v("State属性是Vuex的单一状态树")]),t._v(" "),a("h3",{attrs:{id:"getter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getter"}},[t._v("#")]),t._v(" Getter")]),t._v(" "),a("p",[t._v("有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数")]),t._v(" "),a("p",[t._v("Getter类似于Vue的 computed 对象。是根据业务逻辑来处理State，使得生成业务所需的属性。")]),t._v(" "),a("h3",{attrs:{id:"mutation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mutation"}},[t._v("#")]),t._v(" Mutation")]),t._v(" "),a("p",[t._v("更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。")]),t._v(" "),a("p",[t._v("Mutation是唯一用来更改Vuex中状态的方法。")]),t._v(" "),a("h3",{attrs:{id:"action"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#action"}},[t._v("#")]),t._v(" Action")]),t._v(" "),a("p",[t._v("Action 类似于 mutation，不同在于：")]),t._v(" "),a("ul",[a("li",[t._v("Action 提交的是 mutation，而不是直接变更状态。")]),t._v(" "),a("li",[t._v("Action 可以包含任意异步操作。")])]),t._v(" "),a("p",[t._v("Action是用来解决异步操作而产生的，它提交的是Mutation。")]),t._v(" "),a("h3",{attrs:{id:"module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#module"}},[t._v("#")]),t._v(" Module")]),t._v(" "),a("p",[t._v("由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割")]),t._v(" "),a("p",[t._v("Module是将Vuex模块化的对象，目的是更好的维护。")]),t._v(" "),a("h2",{attrs:{id:"二、vuex中的辅助函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、vuex中的辅助函数"}},[t._v("#")]),t._v(" 二、Vuex中的辅助函数")]),t._v(" "),a("p",[t._v("​\t辅助函数： mapState、mapGetters、mapMutations、mapActions 等")]),t._v(" "),a("h3",{attrs:{id:"如何使用辅助函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何使用辅助函数"}},[t._v("#")]),t._v(" 如何使用辅助函数")]),t._v(" "),a("p",[t._v("首先，需要在当前组件中引入"),a("code",[t._v("Vuex")]),t._v("。")]),t._v(" "),a("p",[t._v("然后，通过Vuex来调用辅助函数。")]),t._v(" "),a("h3",{attrs:{id:"辅助函数如何去映射vuex-store中的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#辅助函数如何去映射vuex-store中的属性"}},[t._v("#")]),t._v(" 辅助函数如何去映射vuex.store中的属性")]),t._v(" "),a("h4",{attrs:{id:"_1、mapstate-把state属性映射到computed身上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、mapstate-把state属性映射到computed身上"}},[t._v("#")]),t._v(" 1、mapState:把state属性映射到computed身上")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("computed")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("Vuex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("input")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("inputVal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("n")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("state")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("state")]),t._v("：用来存储公共的状态 在"),a("code",[t._v("state")]),t._v("中的数据都是响应式的。")]),t._v(" "),a("p",[t._v("响应式原因："),a("code",[t._v("state")]),t._v("里面有一个"),a("code",[t._v("getters")]),t._v("、"),a("code",[t._v("setters")]),t._v("方法；"),a("code",[t._v("data")]),t._v("中的数据也是响应式的，因为里面也有"),a("code",[t._v("getters")]),t._v("和"),a("code",[t._v("setters")]),t._v("方法")]),t._v(" "),a("h4",{attrs:{id:"_2、mapacions-把actions里面的方法映射到methods中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、mapacions-把actions里面的方法映射到methods中"}},[t._v("#")]),t._v(" 2、mapAcions：把actions里面的方法映射到methods中")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("methods")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("Vuex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapActions")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"handleTodoAdd"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//val为actions里面的方法名称")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("change")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"handleInput"')]),t._v("     \n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("actions")]),t._v("里面的函数主要用来处理异步的函数以及一些业务逻辑,每一个函数里面都有一个形参，这个形参是一个对象，里面有一个"),a("code",[t._v("commit")]),t._v("方法，这个方法用来触发mutations里面的方法")]),t._v(" "),a("h4",{attrs:{id:"_3、mapmutations-把mutations里面的方法映射到methods中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、mapmutations-把mutations里面的方法映射到methods中"}},[t._v("#")]),t._v(" 3、mapMutations：把mutations里面的方法映射到methods中")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("methods")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("Vuex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapMutations")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("handleAdd")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"handlMutationseAdd"')]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("mutations")]),t._v("里面的函数主要用来修改"),a("code",[t._v("state")]),t._v("中的数据。"),a("code",[t._v("mutations")]),t._v("里面的所有方法都会有2个参数，一个是"),a("code",[t._v("store")]),t._v("中的"),a("code",[t._v("state")]),t._v("，另外一个是需要传递的参数。")]),t._v(" "),a("p",[t._v("理解"),a("code",[t._v("state")]),t._v("、"),a("code",[t._v("actions")]),t._v("、"),a("code",[t._v("mutations")]),t._v("，可以参考"),a("code",[t._v("MVC")]),t._v("框架。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("state")]),t._v("看成一个数据库，只是它是响应式的，刷新页面数据就会改变；")]),t._v(" "),a("li",[a("code",[t._v("actions")]),t._v("看成controller层，做数据的业务逻辑；")]),t._v(" "),a("li",[a("code",[t._v("mutations")]),t._v("看成model层，做数据的增删改查操作。")])]),t._v(" "),a("h4",{attrs:{id:"_4、mapgetters-把getters属性映射到computed身上"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、mapgetters-把getters属性映射到computed身上"}},[t._v("#")]),t._v(" 4、mapGetters:把getters属性映射到computed身上")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("computed")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("        \n     "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("Vuex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("mapGetters")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("       \n         "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("NumN")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"NumN"')]),t._v("   \n     "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  \n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h4",{attrs:{id:"_5、modules属性-模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、modules属性-模块"}},[t._v("#")]),t._v(" 5、modules属性: 模块")]),t._v(" "),a("p",[t._v("把公共的状态按照模块进行划分")]),t._v(" "),a("ul",[a("li",[t._v("每个模块都相当于一个小型的Vuex")]),t._v(" "),a("li",[t._v("每个模块里面都会有"),a("code",[t._v("state")]),t._v(" "),a("code",[t._v("getters")]),t._v(" "),a("code",[t._v("actions")]),t._v(" "),a("code",[t._v("mutations")])]),t._v(" "),a("li",[t._v("切记在导出模块的时候加一个 "),a("code",[t._v("namespaced:true")]),t._v(" 主要的作用是将每个模块都有独立命名空间")]),t._v(" "),a("li",[a("code",[t._v("namespace：true")]),t._v("在多人协作开发的时候，可能子模块和主模块中的函数名字会相同，这样在调用函数的时候，相同名字的函数都会被调用，就会发生问题。为了解决这个问题，导出模块的时候要加"),a("code",[t._v("namespace：true")]),t._v(".")])]),t._v(" "),a("p",[t._v("那么怎么调用子模块中的函数呢？假如我的子模块名字为todo.js。 函数名字就需要改成todo/函数名字。")]),t._v(" "),a("h2",{attrs:{id:"vuex的核心原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex的核心原理"}},[t._v("#")]),t._v(" Vuex的核心原理")]),t._v(" "),a("p",[t._v("vuex的本质是一个对象")]),t._v(" "),a("p",[t._v("vuex对象有两个属性，一个是install方法，一个是store类")]),t._v(" "),a("p",[t._v("install方法的作用是将store这实例挂载到所有组件上，注意是同一个store实例")]),t._v(" "),a("p",[t._v("store这个类拥有commit方法，dispatch方法，store类里将用户传入的state包装成data，作为new vue的参数，从而实现state值的响应式")])])}),[],!1,null,null,null);a.default=r.exports}}]);